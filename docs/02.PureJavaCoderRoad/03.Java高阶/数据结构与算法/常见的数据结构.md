---
title: 常见的数据结构
date: 2022-05-26 17:04:09
permalink: /pages/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84
lock: false
categories: 
  - PureJavaCoderRoad
  - Java高阶
  - 数据结构与算法
tags: 
  - 常见
  - 数据结构
---
数据结构分类

> 听到数据结构这四个字，小白隐隐约约想起了大学里学过这门课程，但是一点都听不明白，只记得链表、树的概念，考试勉强60分通过。
>
> 小白悔恨当初不好好学习，于是查了一下数据结构的概念，打算重新学习一遍。

**数据结构定义**：指相互之间存在一种或多种特定关系的数据元素的集合。

> 小白：噢~那Java中的集合也算是一种数据结构了
>
> HaC：对的，Java的集合比如list、map、stack都是数据结构，它们已经封装好了，我们可以直接使用。

常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/image-20210407104618787.png)

每一种数据结构都有着独特的数据存储方式，所以选用合适的数据结构去解决业务问题是很有必要的。

## 1、数组

数组是最简单的数据结构了。

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/image-20210407145025409.png)

数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。

```java
int[] data = new int[100];
data[0]  = 1;
```

**优点：**
1、按照索引查询元素速度快
2、按照索引遍历数组方便

缺点：
1、数组的大小固定后就无法扩容了
2、数组只能存储一种类型的数据
3、添加，删除的操作慢，因为要移动其他的元素。

适用场景：
频繁查询，对存储空间要求不大，很少增加和删除的情况。



## 2、栈

栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/20180903195046375)

栈的特点是：**先进后出** 

从栈顶放入元素的操作叫**入栈**（又叫压栈），取出元素叫**出栈**。

栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。

## 3、队列

队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素。

特点是：**先进先出**。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/20180903195109249)

使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。

## 4、链表

链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。

单向链表：

 ![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/20170817220355281)

单向循环链表：

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/20161002201214740)

双向循环链表：

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/20161002201307631)

链表的优点：
链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；
添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；

缺点：
因为含有大量的指针域，占用空间较大；
查找元素需要遍历链表来查找，非常耗时。

适用场景：
数据量较小，需要频繁增加，删除操作的场景

## 5、树

### 树

树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

- 每个节点有零个或多个子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树；

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/2243690-e20ffe8f48bfcfbc.webp)

### 二叉树

在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。

二叉树是树的特殊一种，具有如下特点：

- 每个结点最多有两颗子树，结点的度最大为2。
- 左子树和右子树是有顺序的，次序不能颠倒。
- 即使某结点只有一个子树，也要区分左右子树。

二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/2243690-531c8fbb6b2b55c4.webp)

**扩展：**
二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能。

> mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。

### 二叉查找树

二叉查找树又叫二叉搜索树、二叉排序树，在二叉树的基础上又做了限制，主要体现在它是有序的，特点如下：

- (1) 若左子树不空，则左子树上所有结点的值均小于它的根结点的值
- (2) 若右子树不空，则右子树上所有结点的值均大于它的根结点的值
- (3) 左、右子树也分别为二叉排序树
- (4) 没有键值相等的结点

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/2243690-3560f391373e5e61.png)

虽然二叉查找树是有序的，但叉查找树的平均查找长度和树的形态有关，比如说：

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/2243690-85c04f4b9b730b39.png)

右侧这棵树（右斜树，就像链表一样）的搜索效率降低为 O(n)，

### 平衡二叉树

平衡二叉树又称AVL树，因为两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树。

> 由前苏联的数学家 **A**delse-**V**elskil 和 **L**andis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树

特点是：

- 可以是空树。
- 假如不是空树，**任何一个结点**的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。

举几个例子：

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/image-20210407141642981.png)

以上，第一个 虽然**节点5**的左右子树高度都是3，但是**节点4**的左子树高度是2，右子树高度是0，所以高度差超过了1，就不是平衡二叉树了。第三个同理。

### 红黑树

红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于 1

红黑树的特点：

- (1) 每个节点或者是黑色，或者是红色。
- (2) 根节点是黑色。
- (3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]
- (4) 如果一个节点是红色的，则它的子节点必须是黑色的。
- (5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

关于它的特性，需要注意的是：
第一，特性(3)中的叶子节点，是只为空(NIL或null)的节点。
第二，特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/251730074203156.jpg)



树还有B树、B+树、霍夫曼树等等，可以参考:https://blog.csdn.net/u014532217/article/details/79118023



## 6、散列表

散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。

记录的存储位置=f(key)

这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。

哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。

拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/image-20210407143725029.png)

从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。

jdk1.7版本和1.8版本的HashMap结构图：

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/20200303224420195.png)

哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。

## 7、堆

堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：

- 堆中某个节点的值总是不大于或不小于其父节点的值；
- 堆总是一棵完全二叉树。

将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。

 示例图如下：

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9UZEdMYVNVNjc1Z3dCYXdabTRBdEtieVVVcUVIUnFDS1BGSzdxaWJEaWJVUFFFMWhtb1hmM0oydWhpYkQwSVZxdk9vbHczWGd0aWFvckVzeUpEWXBCYnkzamcvNjQw)

因为堆有序的特点，一般用来做数组中的排序，称为堆排序。

## 8、图

图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。

按照顶点指向的方向可分为无向图和有向图：

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9UZEdMYVNVNjc1Z3dCYXdabTRBdEtieVVVcUVIUnFDS28xaFBvYTg0QTR0RlhFUDVkVTk5R0hpYkhONVh3THNGcDF3UE1mM1Fab1pxWFI1SUY4UFJpYlZ3LzY0MA)

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img-20210401/image-20210407144637998.png)

图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有 邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构 。



---

Java中的集合已经提供了很多开箱即用的集合，如List、LinkedList、HashMap、Stack、Queue等等，不需要我们自己实现（造轮子）。

> 上述图片源自于网络，见水印，如有侵权，烦请联系我删除。

