---
title: 计算机网络面试题
date: 2022-06-02 11:18:21
lock: false
permalink: /pages/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98
categories: 
  - LearnJavaToFindAJob
  - 【初级】6~12k档
  - 计算机网络
tags: 
  - null
---
### 1、7层网络模型

1. 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率
   等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为
   1、0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。

2.  数据链路层：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。常把这
一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。
3.  网络层：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工
作的设备是路由器，常把这一层的数据叫做数据包。
4.  传输层：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：TCP（传输控制协议，
传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，
与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这
种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。
常常把这一层数据叫做段。
5.  会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间
发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）
6.  表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够
识别的东西转换成人能够能识别的东西（如图片、声音等））
7.  应用层 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你
就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。

![OSI 七层网络模型](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img/image-20200925135538062.png)

TCP/IP 则是四层的结构，做了一些简化，它把 应用层、表示层、会话层 合并为**应用层**，把 数据链路层、物理层 合并为**数据链路层** 

![](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img/image-20210322111527303.png)



### 2、 TCP 三次握手

| 字段 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| URG  | 紧急指针是否有效。为1，表示某一位需要被优先处理              |
| ACK  | 确认号是否有效，一般置为1。                                  |
| PSH  | 提示接收端应用程序立即从TCP缓冲区把数据读走。                |
| RST  | 对方要求重新建立连接，复位。                                 |
| SYN  | 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1 |
| FIN  | 希望断开连接。                                               |



TCP 在传输之前会进行三次沟通，一般称为“三次握手”。

![三次握手](https://images-1253198264.cos.ap-guangzhou.myqcloud.com/image-20200925140933780.png)

第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

总结就是：

>A：我想给你发送数据，可以吗？
>
>B：可以，什么时候发？
>
>A：好的，现在就发，你接着。



### 3、四次挥手

TCP 建立连接要进行三次握手，而断开连接要进行四次。

![四次挥手](https://images-1253198264.cos.ap-guangzhou.myqcloud.com/image-20200925141506733.png)

- Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。（我要关闭连接了）
- Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。（你的请求我收到了，但我还没准备好，如果你有数据还要发送请继续发送，请你继续等我消息）
- Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。（好了，我这边数据发送完了，准备关闭连接了）
- Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。（收到，我关闭了，但是担心网络，怕server不知道要关闭，server假如真的没收到可以重传，收到ACK后就知道断开连接了，client等待2msl后没有收到回复，则证明Server已经关闭了，那我也关闭吧）



### 4、为什么连接的时候是三次握手？

主要是防止已过期的连接再次传到被连接的主机。

如果是设计成两次握手，就有可能是被连接方第一次发出ack消息后，就处于成功建立连接的状态，但这条消息丢失了，主动连接方因为没有收到这个ack消息会认为建立连接失败，也许会放弃连接或启动新的连接，但被连接方会一直监听那个它误认为成功的连接。

> 无法做到双向连接的建立

采用三次握手，前两次握手任何一次失败都会导致连接双方都处于未连接状态，第三次失败只会导致连接方处于成功状态，但做主动连接方，肯定会在连接不久后通过这个连接发送数据，这样就可以利用这个机制做进一步的容错。



### 5、为什么关闭的时候是四次挥手？

这是由于 TCP 的半关闭造成的。因为 TCP 连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。

当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。



### 6、DNS解析过程

![域名分类](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img/clipboard-1601961502361.png)

DNS属于应用层。

原理：

DNS解析主要有递归查询，就是在某个DNS服务器缓存中查找不到相应的域名与IP地址对应关系时，自动跳转到到下一步骤通过下一个DNS服务器进行查找。

过程：

1.   浏览器缓存

当用户通过浏览器访问某域名时，首先识别URL中协议，域名，文件路径，端口等信息。，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）； 

1.   系统缓存

查找本地hosts文件，是否存在该域名对应的ip

3. 路由器缓存

若浏览器缓存和系统缓存都找不到该域名对应的ip，则进入路由器缓存。

以上三步都在客户端的DNS缓存。

4. ISP（互联网服务提供商）DNS缓存

当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查5） 根域名服务器 

5. 根域名服务器

当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；

6. 还是找不到则往 顶级域名服务器 、主域名服务器 找

7. 保存结果至缓存，同时将该结果反馈给客户端



### 7、一个Http请求的传输流程

1. 地址解析

如用客户端浏览器请求这个页面：http://localhost.com:8080/index.html 从中分解出协议名、主机名、
端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：

协议名：http
主机名：localhost.com
端口：8080
对象路径：/index.htm

在这一步，需要域名系统 DNS 解析域名 localhost.com,得主机的 IP 地址。

2. 封装 HTTP 请求数据包

把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包

3. 封装成 TCP 包并建立连接

封装成 TCP 包，建立 TCP 连接（TCP 的三次握手）

4. 客户端发送请求命令

求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。

5. 服务器响应

服务器响应http请求（返回码），浏览器得到html代码 ，其格式为一个状态行，包括信息的协议版本号、一个成功或
错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。

6. 解析、渲染

浏览器解析html代码，并请求html代码中的资源（如js、image）

遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这是时候就用上 keep-alive特性了，建立一次HTTP连接，可以请求多个资源。

最后浏览器对页面进行渲染呈现给用户

7. 服务器关闭 TCP 连接

如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive，TCP 连接在发送
后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求
建立新连接所需的时间，还节约了网络带宽。

然后TCP四次挥手。



### 8、http的状态码

|      | 类别                             | 原因短语                                                   |
| ---- | -------------------------------- | ---------------------------------------------------------- |
| 1XX  | Informational（信息性状态码）    | 接受的请求正在处理，服务器收到请求，需要请求者继续执行操作 |
| 2XX  | Success（成功状态码）            | 请求正常处理完毕                                           |
| 3XX  | Redirection（重定向状态码）      | 重定向，需要进一步的操作以完成请求                         |
| 4XX  | Client Error（客户端错误状态码） | 客户端错误，请求包含语法错误或无法完成请求                 |
| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错                                         |

200 ：   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。

301 ：	（Moved Permanently 永久移动）	重定向，浏览器会自动连接到新的URL。
302 ：(Found/找到)  临时重定向
303 ：(See Other/参见其他信息)   临时重定向，必须使用get方式的请求。


400： 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。
401：(Unauthorized/未授权)  协议格式出现了问题。
403： (Forbidden/禁止)   服务器拒绝了你的请求。
405： 客户端请求中的方法被禁止。

500  (Internal Server Error/内部服务器错误)  服务器读取信息之中出错。
503： (Service Unavailable/服务无法获得) 表示服务器由于在维护或已经超载而无法响应 。

502与504的区别：

502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 
504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。



### 9、TCP和UDP的区别

![tcp与udp区别](https://cdn.jsdelivr.net/gh/DogerRain/image@main/img/clipboard-1601961468513.png)

**共同点：**
都是传输层协议

**TCP 为什么是可靠连接（可靠传输）？**

- 通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。
- TCP 报文头里面的序号能使 TCP 的数据按序到达
- 报文头里面的确认序号能保证不丢包，累计确认及超时重传机制
- TCP 拥有流量控制及拥塞控制的机制



### 10、HTTP与HTTPS的区别

| 区别           | HTTP                                                         | HTTPS                                                        |
| :------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| URL            | 以http:// 开头                                               | 以https:// 开头                                              |
| OSI 网络模型中 | 应用层                                                       | 传输层                                                       |
| 协议           | 运行在 TCP 之上，明文传输，**客户端与服务器端都无法验证对方的身份** | 身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， **是添加了加密和认证机制的 HTTP**。 |
| 端口           | 80                                                           | 443                                                          |
| 资源消耗       | 较少                                                         | 由于加解密处理，会消耗更多的 CPU 和内存资源                  |
| 开销           | 无需证书                                                     | 需要CA机构颁发的SSL证书                                      |
| 加密机制       | 无                                                           | 共享密钥加密和公开密钥加密并用的混合加密机制                 |
| 安全性         | 弱                                                           | 由于加密机制，安全性强                                       |



### 11、GET和POST的区别

1. Get是不安全的，因为在传输过程，数据被放在请求的URL中（参数可见）；Post的所有操作对用户来说都是不可见的。 但是这种做法也不是绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。

2. Get请求提交的url中的数据最多只能是`2048`字节，这个限制是浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求；Post请求则没有大小限制。

3. Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。

4. Get执行效率却比Post方法好。Get是form提交的默认方法。

5. GET产生一个TCP数据包；POST产生两个TCP数据包。

   对于GET方式的请求，浏览器会把`http header`和`data`一并发送出去，服务器响应`200 ok`（返回数据）；

   而对于POST，浏览器先发送`header`，服务器响应`100 continue`，浏览器再发送`data`，服务器响应`200 ok`（返回数据）。



### 12、Session、Cookie和Token的主要区别

HTTP协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份。

**什么是cookie**

cookie是由Web服务器保存在用户浏览器上的小文件（key-value格式），包含用户相关的信息。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。

**什么是session**

session是依赖Cookie实现的。session是服务器端对象

session 是浏览器和服务器会话过程中，服务器分配的一块储存空间。服务器默认为浏览器在cookie中设置 sessionid，浏览器在向服务器请求过程中传输 cookie 包含 sessionid ，服务器根据 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。

**cookie与session区别**

- 存储位置与安全性：**cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高；**
- 存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无此限制
- 占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。

**什么是Token**

Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。

Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。

Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位

**session与token区别**

- session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；
- **session存储在服务器端，token存储在客户端**
- token提供认证和授权功能，作为身份认证，token安全性比session好；
- session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下）



### 13、HTTP 2.0 和HTTP 1.0的区别

HTTP2.0 使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小，可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。

在 HTTP/1.0 中，HTTP 1.0规定浏览器与服务器只保持短暂的连接，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。



### 14、一个 TCP 连接可以对应几个 HTTP 请求？

http1.1 的 tcp 连接复用，不能并行，第一个应答对应第一个请求，第二个应答对应第二个请求...依此类推。

所以，理论上支持的请求数是没有限制的。所以，也没有数量限制，你可以在一个 tcp 连接上进行无数次 http 请求。

http2 的 tcp 多路复用，在一条连接里可以并发提供多条流。由于数据包是流的载体，所以不同的流互不相干，也就不存在 pipelining 里的响应顺序依赖的问题，后请求的可以先返回，并行多少个 http 请求是客户端决定的。基本上，不管多少个请求，都会只使用一个 tcp 连接，当然也不会有http请求数限制了。

