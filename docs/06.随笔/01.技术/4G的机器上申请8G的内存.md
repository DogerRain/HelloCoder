先说结论：

- 在 32 位操作系统，因为进程最大只能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。
- 在 64 位操作系统，因为进程最大只能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。



---



首先要知道前提条件：

- 操作系统是32位还是64位
- 申请后的8G内存是否真的被使用
- 操作系统是否开启了 Swap机制

> 32位 寻址的范围是2^32也就是4G
>
> 64位的话则有 128T



还需要明白一体下面几个概念。

## 物理内存

物理内存可以理解为电脑的内存条，是真正的内存。



## 虚拟内存

虚拟内存的出现，就是为了解决直接使用物理内存的问题。

虚拟内存是为了满足**物理内存不足时**而提出的策略，他是利用磁盘空间虚拟出的逻辑内存，用作虚拟内存的磁盘空间被称为交换空间（swap space）



进程要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址，这又 涉及到内存管理单元（MMU）和地址映射。



程序在申请内存的时候，都是直接和 虚拟内存 打交道的。



## 申请内存



是否允许申请跟 Linux 中的 overcommit_memory 参数有关，可以使用 `cat /proc/sys/vm/overcommit_memory` 来查看这个参数，这个参数接受三个值：

- 如果值为 0（默认值），代表：Heuristic overcommit handling，它允许overcommit，但过于明目张胆的 overcommit 会被拒绝，比如malloc一次性申请的内存大小就超过了系统总内存。Heuristic的意思是“试探式的”，内核利用某种算法猜测你的内存申请是否合理，大概可以理解为单次申请不能超过free memory + free swap + pagecache的大小 + SLAB中可回收的部分 ，超过了就会拒绝overcommit。
- 如果值为 1，代表：Always overcommit. 允许overcommit，对内存申请来者不拒。
- 如果值为 2，代表：Don’t overcommit. 禁止overcommit。





还有一种情况

即使 malloc 申请的是虚拟内存，只要不去访问就不会映射到物理内存，但是申请虚拟内存的过程中，还是使用到了物理内存（比如内核保存虚拟内存的数据结构，也是占用物理内存的），如果你的主机是只有 2GB 的物理内存的话，大概率会触发 OOM。