(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{499:function(v,_,a){"use strict";a.r(_);var n=a(7),t=Object(n.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"分布式事务的实现方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务的实现方式"}},[v._v("#")]),v._v(" 分布式事务的实现方式")]),v._v(" "),_("p",[v._v("首先需要先指定CAP理论。")]),v._v(" "),_("ul",[_("li",[v._v("C consistency 一致性： 所有节点同一时间具有相同的数据")]),v._v(" "),_("li",[v._v("A availability 可用性： 节点可用，每个请求都能收到非错误性的响应")]),v._v(" "),_("li",[v._v("P partition tolerance 分区容错性： 节点不能因网络分区而崩溃")])]),v._v(" "),_("p",[v._v("在分布式系统中，CAP理论的一个限制是： CAP理论的实现中，只能同时满足两个条件。而 P 是必须的，我们通常会选择 AP，牺牲 C 强一致性。")]),v._v(" "),_("p",[v._v("通常放弃强一致性（如 2PC/XA），转而追求最终一致性（Eventual Consistency）")]),v._v(" "),_("p",[v._v("实现方案大致如下：")]),v._v(" "),_("h3",{attrs:{id:"_1、基于-本地消息表-local-message-table"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、基于-本地消息表-local-message-table"}},[v._v("#")]),v._v(" 1、基于“本地消息表” (Local Message Table)")]),v._v(" "),_("p",[v._v("这是最经典、最不依赖特定中间件特性的方案，适用于对一致性要求极高的场景 。")]),v._v(" "),_("p",[v._v("具体流程如下：")]),v._v(" "),_("ol",[_("li",[v._v("利用数据库的分布式事务，保证原子性。（业务数据+消息记录 在同一个事务里面完成，成功提交，失败则回滚）")]),v._v(" "),_("li",[v._v("定时任务扫描，独立后台任务轮询扫描待处理的消息，最后更新。")])]),v._v(" "),_("blockquote",[_("p",[v._v("使用定时任务扫描，可以提高对接口的容错性，从而提升系统的可用性。")])]),v._v(" "),_("p",[v._v("优点：不依赖第三方中间件，可靠性极高。实现简单，容易排查回溯，适用于大多数场景。\n缺点：实时性差，有延迟，定时任务对数据库压力颇大")]),v._v(" "),_("h3",{attrs:{id:"_2、mq-消息中间件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、mq-消息中间件"}},[v._v("#")]),v._v(" 2、MQ 消息中间件")]),v._v(" "),_("p",[v._v("基于“事务消息” (Transactional Messaging)")]),v._v(" "),_("p",[v._v("这是目前互联网大厂（特别是阿里系技术栈）非常主流的方案，典型代表是 RocketMQ。它其实是“本地消息表”的封装和优化。")]),v._v(" "),_("p",[v._v("核心在于它解决了本地事务与消息发送的原子性问题，即保证：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("业务操作成功，消息一定能被消费")])]),v._v(" "),_("li",[_("p",[v._v("业务操作失败，消息一定不会被消费")])])]),v._v(" "),_("p",[_("strong",[v._v("核心流程（RocketMQ 为例）：")])]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("发送半消息（Half Message）")]),v._v("：生产者向 MQ 发送一条“半消息”，MQ 收到后持久化但不投递（消费者看不见）。")]),v._v(" "),_("li",[_("strong",[v._v("执行本地事务")]),v._v("：生产者执行本地业务逻辑。")]),v._v(" "),_("li",[_("strong",[v._v("提交/回滚")]),v._v("：\n"),_("ul",[_("li",[v._v("如果本地事务成功，向 MQ 发送 "),_("strong",[v._v("Commit")]),v._v("，MQ 将消息改为“可投递”，消费者收到消息。")]),v._v(" "),_("li",[v._v("如果本地事务失败，向 MQ 发送 "),_("strong",[v._v("Rollback")]),v._v("，MQ 删除消息。")])])]),v._v(" "),_("li",[_("strong",[v._v("回查机制（关键点）")]),v._v("：如果 MQ 长时间没收到 Commit/Rollback（比如网络断了），MQ 会反向回调生产者的接口，检查本地事务的状态，从而决定是提交还是回滚。")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("┌─────────┐     1.发送Half消息     ┌─────────┐\n│ Producer│───────────────────────▶│ MQ Server │\n└────┬────┘                        └─────┬───┘\n     │        2.返回发送结果             │\n     │◀─────────────────────────────────│\n     │                                   │\n     │ 3.执行本地事务                    │\n     │ (数据库操作)                      │\n     │                                   │\n     │4.提交/回滚事务状态                │\n     │─────────────────────────────────▶│\n     │                                   │\n     │                                   │5.MQ定时检查\n     │                                   │ 事务状态\n     │                                   │ (回查机制)\n     │◀─────────────────────────────────│\n     │                                   │\n     │6.返回最终事务状态                 │\n     │─────────────────────────────────▶│\n     │                                   │\n     │                                   │7.提交/回滚消息\n     │                                   │ (对消费者可见/删除)\n     │                                   │\n     │                                   ▼\n┌────┴────┐                        ┌─────────┐     8.消费消息\n│Producer │                        │ MQ Server│─────────────────┐\n│本地事务   │                        │         │                 │\n└─────────┘                        └─────────┘                 │\n                                                                ▼\n                                                         ┌─────────┐\n                                                         │Consumer │\n                                                         └─────────┘\n")])])]),_("p",[_("strong",[v._v("优点")]),v._v("：业务解耦，不需要维护本地消息表，性能更好。")]),v._v(" "),_("p",[_("strong",[v._v("缺点")]),v._v("：强依赖支持事务消息的 MQ 中间件（RabbitMQ、Kafka 原生不支持这种强一致性逻辑，需要魔改）。")]),v._v(" "),_("h3",{attrs:{id:"方案三-saga-模式-长事务编排"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方案三-saga-模式-长事务编排"}},[v._v("#")]),v._v(" 方案三：Saga 模式 (长事务编排)")]),v._v(" "),_("p",[v._v("当你的业务本身就是由多个步骤组成的长时间过程时，Saga是比TCC更轻量、更适合最终一致性的模式。")]),v._v(" "),_("p",[v._v("通过将大事务分解为一系列有序的、可以独立执行的本地事务来管理一致性。这些本地事务通过协调器或者事件驱动的方式依次执行，如果其中一个事务失败，则使用相应的补偿事务来撤销之前已经完成的事务，以确保系统的一致性，属于补偿性事务。")])])}),[],!1,null,null,null);_.default=t.exports}}]);