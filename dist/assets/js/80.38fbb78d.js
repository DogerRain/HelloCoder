(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{496:function(t,s,a){"use strict";a.r(s);var n=a(7),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"reentrantlock的原理是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock的原理是什么"}},[t._v("#")]),t._v(" ReentrantLock的原理是什么？")]),t._v(" "),s("p",[t._v("“"),s("code",[t._v("ReentrantLock")]),t._v(" 是 java.util.concurrent 包下基于 AQS 实现的可重入互斥锁。**，通过一个volatile的state状态变量和一个CLH变体的双向等待队列来实现可重入的独占锁。**它主要用于替代 "),s("code",[t._v("synchronized")]),t._v("，但在功能上更加灵活和强大。”")]),t._v(" "),s("h2",{attrs:{id:"核心实现机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#核心实现机制"}},[t._v("#")]),t._v(" 核心实现机制")]),t._v(" "),s("p",[s("code",[t._v("ReentrantLock")]),t._v(" 的核心原理可以概括为："),s("strong",[t._v("AQS 框架 + CAS 原子操作 + "),s("code",[t._v("state")]),t._v(" 状态机")])]),t._v(" "),s("p",[t._v("1、AQS (AbstractQueuedSynchronizer)")]),t._v(" "),s("p",[t._v("AQS 维护了一个 volatile int state（同步状态）和一个 FIFO（先进先出）的线程等待队列（CLH 队列）。")]),t._v(" "),s("blockquote",[s("p",[t._v("CLH锁其实就是一种基于逻辑队列非线程饥饿的一种自旋公平锁。当多线程竞争一把锁时，获取不到锁的线程，会排队进入CLH队列的队尾，然后自旋等待，直到其前驱线程释放锁。")])]),t._v(" "),s("p",[t._v("作用：AQS 负责管理阻塞队列、唤醒线程、维护同步状态，是锁的底层基础设施。")]),t._v(" "),s("p",[t._v("2、 "),s("strong",[t._v("CAS操作")]),t._v("：")]),t._v(" "),s("p",[t._v("通过Unsafe类的CAS保证state变更的原子性（无锁原子算法）")]),t._v(" "),s("p",[t._v("3、state "),s("strong",[t._v("状态管理")]),t._v("：")]),t._v(" "),s("p",[t._v("使用一个"),s("code",[t._v("volatile int state")]),t._v("变量表示锁状态")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("state = 0")]),t._v("：锁空闲")]),t._v(" "),s("li",[s("code",[t._v("state > 0")]),t._v("：锁被占用，重入次数")])]),t._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[s("strong",[t._v("等待队列")]),t._v("：基于CLH队列变体的双向链表，保存等待获取锁的线程")])]),t._v(" "),s("h2",{attrs:{id:"加锁流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#加锁流程"}},[t._v("#")]),t._v(" 加锁流程")]),t._v(" "),s("p",[t._v("非公平锁流程：")]),t._v(" "),s("blockquote",[s("p",[t._v("“先CAS插队抢一次，抢不到再走 AQS 排队流程。")])]),t._v(" "),s("p",[t._v("步骤 1: 尝试 CAS 抢占（非公平插队）, AQS 的 "),s("code",[t._v("state")]),t._v(" 状态从 "),s("code",[t._v("0")]),t._v(" 变为 "),s("code",[t._v("1")]),t._v("。")]),t._v(" "),s("p",[t._v("步骤 2: 插队失败后，再次尝试及进入 AQS 核心流程，线程会进入 AQS 的 "),s("code",[t._v("acquire(1)")])]),t._v(" "),s("p",[t._v("步骤3: 还是失败，将线程包装成Node加入等待队列，进入自旋，不断尝试获取锁或挂起等待")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://rainyudianxx.baimuxym.cn/HelloCoder/blog/reentrantLock-lock-process.png",alt:""}})]),t._v(" "),s("p",[t._v("公平锁：")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://rainyudianxx.baimuxym.cn/HelloCoder/blog/image-20251202164323970.png",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"与synchronized对比的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#与synchronized对比的优势"}},[t._v("#")]),t._v(" 与synchronized对比的优势")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("可中断")]),t._v("：支持"),s("code",[t._v("lockInterruptibly()")]),t._v("，等待锁时可响应中断")]),t._v(" "),s("li",[s("strong",[t._v("超时机制")]),t._v("：支持"),s("code",[t._v("tryLock(timeout)")]),t._v("，避免无限等待")]),t._v(" "),s("li",[s("strong",[t._v("公平选择")]),t._v("：可选择公平或非公平策略")]),t._v(" "),s("li",[s("strong",[t._v("多条件")]),t._v("：一个锁可以关联多个Condition")])]),t._v(" "),s("h2",{attrs:{id:"公平和非公平锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#公平和非公平锁"}},[t._v("#")]),t._v(" 公平和非公平锁")]),t._v(" "),s("p",[t._v("非公平锁是“先抢再说”。它不关心队列里有没有人，先抢一把，抢不到再排队。")]),t._v(" "),s("p",[t._v("公平锁是“先排队等候”。它确保了等待时间最长的线程优先获取锁。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[s("strong",[t._v("特性")])]),t._v(" "),s("th",[s("strong",[t._v("非公平锁（默认）")])]),t._v(" "),s("th",[s("strong",[t._v("公平锁")])])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("strong",[t._v("抢锁时机")])]),t._v(" "),s("td",[t._v("立即尝试 CAS 抢锁（插队）。")]),t._v(" "),s("td",[t._v("只有在队列为空时才尝试 CAS 抢锁。")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("队列检查")])]),t._v(" "),s("td",[t._v("不检查队列，直接尝试抢。")]),t._v(" "),s("td",[t._v("严格检查队列，若有人排队则排队。")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("性能")])]),t._v(" "),s("td",[t._v("吞吐量高。")]),t._v(" "),s("td",[t._v("吞吐量较低。")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("风险")])]),t._v(" "),s("td",[t._v("可能导致排队线程“饥饿”。")]),t._v(" "),s("td",[t._v("保证了线程的绝对公平性。")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("设计理念")])]),t._v(" "),s("td",[t._v("追求高性能。")]),t._v(" "),s("td",[t._v("追求严格的公平性。")])])])]),t._v(" "),s("p",[t._v("获取锁时的行为差异：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"left"}},[t._v("场景")]),t._v(" "),s("th",{staticStyle:{"text-align":"left"}},[t._v("公平锁 (FairSync)")]),t._v(" "),s("th",{staticStyle:{"text-align":"left"}},[t._v("非公平锁 (NonfairSync)")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"left"}},[s("strong",[t._v("锁空闲时")])]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("先检查队列是否有等待者 有则排队，无则尝试CAS")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("直接尝试CAS抢锁")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[s("strong",[t._v("锁被持有时")])]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("加入队列末尾等待")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("直接尝试一次tryAcquire 失败才入队")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[s("strong",[t._v("唤醒后")])]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("严格按照队列顺序")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v('新线程可能"插队"抢锁')])])])]),t._v(" "),s("h3",{attrs:{id:"公平锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#公平锁"}},[t._v("#")]),t._v(" 公平锁")]),t._v(" "),s("p",[t._v("公平锁核心：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// FairSync.tryAcquire() 方法的关键部分")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" acquires"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" current "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getState")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 锁空闲时")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ↓↓↓ 公平性的关键检查 ↓↓↓")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hasQueuedPredecessors")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 检查是否有前驱等待者")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetState")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" acquires"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setExclusiveOwnerThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("current"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 重入逻辑与非公平锁相同...")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 判断队列中是否有前驱等待者")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hasQueuedPredecessors")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 尾节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 头节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 三种情况返回true（表示有前驱等待者）：")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1. h != t 且 (h.next == null)      -> 有其他线程正在入队")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2. h != t 且 s.thread != current  -> 队首不是当前线程")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3. h == t                          -> 队列为空（实际上不会执行到这里）")]),t._v("\n    \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" \n           "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("thread "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("公平锁的公平性依赖于"),s("strong",[t._v("AQS的FIFO等待队列")]),t._v("：")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("入队顺序")]),t._v("：严格按照请求锁的时间顺序")]),t._v(" "),s("li",[s("strong",[t._v("出队顺序")]),t._v("：严格按照入队顺序")]),t._v(" "),s("li",[s("strong",[t._v("唤醒机制")]),t._v("：只唤醒队首线程")])]),t._v(" "),s("div",{staticClass:"language-xml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-xml"}},[s("code",[t._v("// 等待队列结构示意\nHEAD → Node(Thread1) → Node(Thread2) → Node(Thread3) → TAIL\n   ↑                                    ↑\n持有锁的线程                        最新等待的线程\n")])])]),s("p",[t._v("ReentrantLock 默认是"),s("strong",[t._v("非公平锁")]),t._v("，因为它允许新来的线程插队尝试 CAS 获取锁，这能利用线程调度的空档期，大幅提升吞吐量。而公平锁严格遵循 FIFO，虽然公平但性能较差。”")]),t._v(" "),s("p",[s("strong",[t._v("ReentrantLock通过"),s("code",[t._v("hasQueuedPredecessors()")]),t._v("方法实现公平性")]),t._v('，在获取锁前先检查是否有更早的等待者。这个简单的检查机制确保了"先来先服务"的原则，但以一定的性能开销为代价。')])])}),[],!1,null,null,null);s.default=e.exports}}]);