(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{491:function(n,o,v){"use strict";v.r(o);var _=v(7),t=Object(_.a)({},(function(){var n=this,o=n._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("h2",{attrs:{id:"synchronized-是公平锁吗"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-是公平锁吗"}},[n._v("#")]),n._v(" Synchronized 是公平锁吗？")]),n._v(" "),o("p",[o("code",[n._v("Synchronized")]),n._v(" 天生就是非公平锁，而且无法设置为公平锁。")]),n._v(" "),o("p",[n._v("什么是公平锁和非公平锁？")]),n._v(" "),o("p",[n._v("公平锁：线程按照请求锁的顺序严格获取锁。如果队列中有线程在等待，新来的线程必须排队。")]),n._v(" "),o("p",[n._v("非公平锁：允许新来的线程（插队者）在锁被释放时，直接尝试获取锁，而不管等待队列中是否已经有线程在等待。")]),n._v(" "),o("p",[n._v("如何理解它是非公平的？")]),n._v(" "),o("p",[n._v("我们需要了解一下"),o("code",[n._v("Synchronized")]),n._v(" 的工作原理：")]),n._v(" "),o("p",[o("code",[n._v("synchronized")]),n._v(" 在 JVM 层面基于 "),o("strong",[n._v("Monitor（管程）")]),n._v(" 实现。当线程进入一个 "),o("code",[n._v("synchronized")]),n._v(" 块时，它会尝试获取对象 Monitor 的所有权。")]),n._v(" "),o("blockquote",[o("p",[n._v("JVM 会申请一个操作系统层面的 互斥量（Mutex Lock），也称为监视器锁（Monitor）。")])]),n._v(" "),o("p",[n._v("当锁被释放时，所有在 "),o("strong",[n._v("Contention Set")]),n._v("（竞争集）或 "),o("strong",[n._v("Entry Set")]),n._v("（进入集）中等待的线程都会被唤醒（或通知），然后它们会竞争重新进入 Monitor 的权利。")]),n._v(" "),o("p",[o("code",[n._v("synchronized")]),n._v(" 无法保证等待线程的获取顺序，没有像 "),o("code",[n._v("ReentrantLock")]),n._v(" 的 CLH 队列。 只能依赖 OS 调度（随机性）。")]),n._v(" "),o("p",[n._v("那么 新线程可以直接尝试竞争，它通常会比那些刚被唤醒的、需要经历上下文切换的线程更快一步获取到锁。这就是典型的"),o("strong",[n._v("插队行为")]),n._v("。")])])}),[],!1,null,null,null);o.default=t.exports}}]);