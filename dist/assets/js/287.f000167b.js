(window.webpackJsonp=window.webpackJsonp||[]).push([[287],{692:function(e,_,v){"use strict";v.r(_);var s=v(7),t=Object(s.a)({},(function(){var e=this,_=e._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("blockquote",[_("p",[e._v("众所周知，sleep是让线程处于等待运行状态，不会占用CPU，OS会将执行时间分配给其它线程。")]),e._v(" "),_("p",[e._v("sleep(0)字面意思是睡眠0毫秒，大家可能觉得跟没写一样，其实不是的。")]),e._v(" "),_("p",[e._v("sleep(1000)比较容易理解，就是让线程睡眠1000毫秒，但是1000毫秒后，线程会执行吗，是立即执行吗？")])]),e._v(" "),_("p",[e._v("本篇文章主要是探究以上的问题。")]),e._v(" "),_("h2",{attrs:{id:"_1、sleep-函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、sleep-函数"}},[e._v("#")]),e._v(" 1、sleep()函数")]),e._v(" "),_("p",[_("code",[e._v("Thread.sleep(long millis)")]),e._v(" 简单的说就是指让当前正在运行的占用cpu时间片的线程挂起 millis ms，线程进入TIMED_WAITING状态,"),_("strong",[e._v("但不释放对象锁")]),e._v("，然后把CPU的资源让给其他线程，但是我们只能指定了线程休眠时间，不能决定CPU的调度，不能决定接下来是哪个线程执行，而让这些线程自己去竞争，一般是OS根据线程的优先度执行。但是，millis后线程自动苏醒进入就绪状态，即线程的睡眠时间到了，它也不会立马被执行。")]),e._v(" "),_("h2",{attrs:{id:"_2、-windows和unix的竞争策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、-windows和unix的竞争策略"}},[e._v("#")]),e._v(" 2、 windows和Unix的竞争策略")]),e._v(" "),_("p",[e._v("Unix系统：时间片算法，一个轮询方法，给每个线程指定的运行时间，如果指定时间还没执行完毕，就剥夺CPU资源给到下一个线程，如果在指定时间前运行完毕或者阻塞了，CPU会检测立马进行切换。")]),e._v(" "),_("p",[e._v("Windows：抢占式算法，一个线程获得了CPU资源，触发自己主动放弃使用CPU，不然会一直霸占CPU资源，或者遇到优先级更高的线程，OS发起一次重新调度，高优先级的线程才有机会继续执行。 有一些线程会主动挂起，这时候OS重新计算一次所有进程的总优先级，选出一个优先级最高的线程交给CPU。")]),e._v(" "),_("h2",{attrs:{id:"_3、sleep-0-和sleep-1000"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、sleep-0-和sleep-1000"}},[e._v("#")]),e._v(" 3、sleep(0)和sleep(1000)")]),e._v(" "),_("p",[e._v("引用自马老师的经典比喻。")]),e._v(" "),_("p",[e._v("我们用上厕所这件事来说描述一下这两种竞争策略。厕所的马桶是CPU，有两个人等上厕所，分别是胖虎和小夫（2个进程）。")]),e._v(" "),_("p",[_("strong",[e._v("如果是Unix系统")]),e._v("，每个人轮流上厕所10分钟，胖虎先上，时间到了，轮到小夫，这样两个人都能上厕所了，当然，如果胖虎10分钟都没解决，那么厕所管理员（OS）只能把胖虎强硬拉出来，让小夫去；或者胖虎提前解决了（挂起），就告诉厕所管理员我已经解决了，让下一位上，然后管理员就让小夫上了。")]),e._v(" "),_("p",[_("strong",[e._v("如果是 Windows 操作系统")]),e._v("，假如胖虎排泄量大，地位高，厕所管理员（OS）会根据胖虎的小夫的情况做一个排序，最后选择出胖虎，直到胖虎不想用厕所了。等胖虎用完了，然后厕所管理员（OS）再排序一次。")]),e._v(" "),_("p",[e._v("胖虎上完厕所刚提裤子，这时候又来了大雄和静香，他们两个人的优先级更急，这时候厕所管理员（OS）要把大雄和静香排在小夫面前，这样小夫就很难有机会上厕所了；")]),e._v(" "),_("p",[e._v("还有一种情况就是，万一胖虎又想上厕所， 优先级还是比小夫高，这样胖虎上了多次厕所，也轮不到小夫；")]),e._v(" "),_("p",[e._v("也有可能是厕所管理员（OS）觉得静香是个女孩子，要怜香惜玉，但是静香不想上厕所（不要你觉得我要我觉得），但是在厕所管理员（OS）这里优先级就是比小夫要上厕所的优先级高。")]),e._v(" "),_("p",[_("code",[e._v("Thread.Sleep(1 * 60 * 60 * 1000)")]),e._v(" 就是说，静香表示不想上厕所了，我想休息一下跟管理员说 一个小时内不要叫我上厕所，我不需要了，然后把厕所让给别人，然后管理员就知道了，下次优先级竞争就不需要把静香纳入计算了。")]),e._v(" "),_("p",[_("code",[e._v("sleep(0)")]),e._v(" 的话，就是说静香表示我现在上厕所中，会不会还有比我更需要使用厕所的人，比如小夫这么惨都没上过厕所，然后她告诉管理员，在未来的 0毫秒之内不要再叫我上厕所，管理员也是接受这个0毫秒的，但是只是0毫秒，管理员在优先级排序的时候，一样会把静香纳入计算，和"),_("code",[e._v("Thread.Sleep(1 * 60 * 60 * 1000)")]),e._v(" 一样，休息1小时后同样的也会把自己纳入重新计算。")]),e._v(" "),_("blockquote",[_("p",[e._v("因此，Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。")])]),e._v(" "),_("h2",{attrs:{id:"_4、sleep-1000-线程睡眠1000毫秒后-线程会执行吗-是立即执行吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、sleep-1000-线程睡眠1000毫秒后-线程会执行吗-是立即执行吗"}},[e._v("#")]),e._v(" 4、sleep(1000) ，线程睡眠1000毫秒后，线程会执行吗，是立即执行吗？")]),e._v(" "),_("p",[e._v("会执行，但不一定是立即执行。")]),e._v(" "),_("p",[e._v("静香（线程）只是告诉厕所管理员（OS）：在未来的1000毫秒内不想再参与到厕所（CPU）的竞争。那么1000毫秒过去之后，这时候也许大雄正在使用厕所，那么这时候厕所管理员是不会重新分配厕所的，直到大雄结束（或者提前结束）或者大雄突然抽筋了不能使用厕所（阻塞）；况且，即使这个时候厕所管理员恰巧进行 厕所分配，那么当前静香也不一定就是总优先级最高的那个，厕所还是可能被胖虎、大雄、小夫 抢占去。")]),e._v(" "),_("blockquote",[_("p",[e._v("与此相似的，Thread有个Resume 函数，是用来唤醒挂起的线程。好像上面所说的一样，这个函数只是"),_("strong",[e._v("告诉操作系统我从现在起开始参与CPU竞争了，这个函数的调用并不能马上使得这个线程获得CPU控制权")]),e._v("。")])]),e._v(" "),_("p",[e._v("操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。")]),e._v(" "),_("p",[e._v("有时候我们的大循环造成程序假死（看到都是一个方法在输出这种），并不是因为这个线程一直在霸占着CPU。"),_("strong",[e._v("实际上在这段时间操作系统已经进行过多次CPU竞争了")]),e._v("，只不过其他线程在获得CPU控制权之后很短时间内马上就退出了，于是就又轮到了这个线程继续执行循环，于是就又用了很久才被操作系统强制挂起。我们看起来就好像这个线程一直在霸占着CPU一样，其实不然。")]),e._v(" "),_("p",[e._v("由于粒度的原因，诸如sleep（1）之类的时间可能会长于1毫秒，所以sleep(1)会进入到睡眠然后进入等待状态；但sleep(0)不会，如果线程调度器的可运行队列中有大于或等于当前线程优先级的就绪线程存在，操作系统会将当前线程从处理器上移除，"),_("strong",[e._v("时间片只能让给优先级相同或更高的线程")]),e._v("，如果可运行队列中的没有就绪线程或所有就绪线程的优先级均低于当前线程优先级，那么当前线程会继续执行，就像没有调用 Sleep(0)一样。")]),e._v(" "),_("h2",{attrs:{id:"_5、总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5、总结"}},[e._v("#")]),e._v(" 5、总结")]),e._v(" "),_("ol",[_("li",[e._v("Thread.Sleep(0) 并非是真的要线程挂起0毫秒，意义在于这次调用Thread.Sleep(0)的当前线程确实的被冻结了一下，让其他线程有机会优先执行。Thread.Sleep(0) 是你的线程暂时放弃cpu，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个让位动作。")]),e._v(" "),_("li",[e._v("sleep(n)之所以在n秒内不会参与CPU竞争，是因为当线程调用sleep(n)的时候，线程是由运行态转入等待态，线程被放入等待队列中，等待定时器n秒后的中断事件，当到达n秒计时后，"),_("strong",[e._v("线程才重新由等待态转入就绪态")]),e._v("，被放入就绪队列中，"),_("strong",[e._v("等待队列中的线程是不参与cpu竞争的，只有就绪队列中的线程才会参与cpu竞争")]),e._v("，所谓的cpu调度，就是根据一定的算法（优先级，FIFO等。。。），从就绪队列中选择一个线程来分配cpu时间。而sleep(0)之所以马上回去参与cpu竞争，是因为调用sleep(0)后，"),_("strong",[e._v("因为0的原因，线程直接回到就绪队列")]),e._v("，而非进入等待队列，只要进入就绪队列，那么它就参与cpu竞争。")])]),e._v(" "),_("p",[e._v("参考：")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://www.cnblogs.com/keyyang/p/4128424.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.cnblogs.com/keyyang/p/4128424.html"),_("OutboundLink")],1)]),e._v(" "),_("p",[_("a",{attrs:{href:"https://www.cnblogs.com/keyyang/p/4128424.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.cnblogs.com/keyyang/p/4128424.html"),_("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=t.exports}}]);