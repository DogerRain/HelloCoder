(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{453:function(_,t,v){"use strict";v.r(t);var r=v(7),d=Object(r.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"spring的传播行为有哪些-隔离级别有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring的传播行为有哪些-隔离级别有哪些"}},[_._v("#")]),_._v(" Spring的传播行为有哪些？隔离级别有哪些？")]),_._v(" "),t("p",[_._v("这个需要配合代码才能讲清楚。（下一章节会讲到）")]),_._v(" "),t("p",[t("strong",[_._v("spring事务的本质其实就是数据库对事务的支持。")])]),_._v(" "),t("p",[t("strong",[_._v("Spring 事务的传播属性")])]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("常量名称")]),_._v(" "),t("th",[_._v("常量解释")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("PROPAGATION_REQUIRED")]),_._v(" "),t("td",[_._v("支持当前事务，如果当前没有事务，就"),t("strong",[_._v("新建一个事务")]),_._v("。这是最常见的选择，也是 Spring 默认的事务的传播。")])]),_._v(" "),t("tr",[t("td",[_._v("PROPAGATION_REQUIRES_NEW")]),_._v(" "),t("td",[_._v("新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作")])]),_._v(" "),t("tr",[t("td",[_._v("PROPAGATION_SUPPORTS")]),_._v(" "),t("td",[_._v("支持当前事务，如果当前没有事务，就以非事务方式执行。")])]),_._v(" "),t("tr",[t("td",[_._v("PROPAGATION_MANDATORY")]),_._v(" "),t("td",[_._v("支持当前事务，如果当前没有事务，就抛出异常。")])]),_._v(" "),t("tr",[t("td",[_._v("PROPAGATION_NOT_SUPPORTED")]),_._v(" "),t("td",[_._v("以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。")])]),_._v(" "),t("tr",[t("td",[_._v("PROPAGATION_NEVER")]),_._v(" "),t("td",[_._v("以非事务方式执行，如果当前存在事务，则抛出异常。")])]),_._v(" "),t("tr",[t("td",[_._v("PROPAGATION_NESTED")]),_._v(" "),t("td",[_._v("如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。")])])])]),_._v(" "),t("p",[t("strong",[_._v("数据库隔离级别")])]),_._v(" "),t("p",[_._v("（innodb才支持）")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("隔离级别")]),_._v(" "),t("th",[_._v("隔离级别的值")]),_._v(" "),t("th",[_._v("导致的问题")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("Read-Uncommitted")]),_._v(" "),t("td",[_._v("0")]),_._v(" "),t("td",[_._v("导致脏读")])]),_._v(" "),t("tr",[t("td",[_._v("Read-Committed")]),_._v(" "),t("td",[_._v("1")]),_._v(" "),t("td",[_._v("避免脏读，允许不可重复读和幻读")])]),_._v(" "),t("tr",[t("td",[_._v("Repeatable-Read")]),_._v(" "),t("td",[_._v("2")]),_._v(" "),t("td",[_._v("避免脏读，不可重复读，允许幻读")])]),_._v(" "),t("tr",[t("td",[_._v("Serializable")]),_._v(" "),t("td",[_._v("3")]),_._v(" "),t("td",[_._v("串行化读，事务只能一个一个执行，避免了脏读、不可重复读、幻读。执行效率慢，使用时慎重")])])])]),_._v(" "),t("p",[t("strong",[_._v("Spring中的隔离级别")])]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("常量")]),_._v(" "),t("th",[_._v("解释")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("ISOLATION_DEFAULT")]),_._v(" "),t("td",[_._v("这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。")])]),_._v(" "),t("tr",[t("td",[_._v("ISOLATION_READ_UNCOMMITTED")]),_._v(" "),t("td",[_._v("这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。")])]),_._v(" "),t("tr",[t("td",[_._v("ISOLATION_READ_COMMITTED")]),_._v(" "),t("td",[_._v("保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。")])]),_._v(" "),t("tr",[t("td",[_._v("ISOLATION_REPEATABLE_READ")]),_._v(" "),t("td",[_._v("这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。")])]),_._v(" "),t("tr",[t("td",[_._v("ISOLATION_SERIALIZABLE")]),_._v(" "),t("td",[_._v("这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。")])])])]),_._v(" "),t("h2",{attrs:{id:"假如spring的隔离级别和数据库隔离级别不一致"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#假如spring的隔离级别和数据库隔离级别不一致"}},[_._v("#")]),_._v(" 假如Spring的隔离级别和数据库隔离级别不一致？")]),_._v(" "),t("p",[_._v("以Spring的为准。")]),_._v(" "),t("p",[_._v("spring开启事务时，拿到的当前连接，会对当前会话设置事务隔离级别。")])])}),[],!1,null,null,null);t.default=d.exports}}]);