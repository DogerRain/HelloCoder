(window.webpackJsonp=window.webpackJsonp||[]).push([[254],{671:function(a,_,t){"use strict";t.r(_);var v=t(7),e=Object(v.a)({},(function(){var a=this,_=a._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("p",[a._v("Java 虚拟机遇到 "),_("code",[a._v("new")]),a._v(" 指令时，对象创建流程并非一步到位，通常需要经过以下 6 个步骤：")]),a._v(" "),_("h3",{attrs:{id:"_1-类加载检查-class-loading-check"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-类加载检查-class-loading-check"}},[a._v("#")]),a._v(" 1. 类加载检查 (Class Loading Check)")]),a._v(" "),_("p",[a._v("JVM 会检查这个类是否已被加载（Load）、链接（Link）和初始化（Initialize）。")]),a._v(" "),_("ul",[_("li",[a._v("如果类尚未加载，则必须先执行相应的类加载过程。参考："),_("a",{attrs:{href:"/pages/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"}},[a._v("类加载机制")])])]),a._v(" "),_("h3",{attrs:{id:"_2-内存分配-memory-allocation"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-内存分配-memory-allocation"}},[a._v("#")]),a._v(" 2. 内存分配 (Memory Allocation)")]),a._v(" "),_("p",[a._v("对象所需内存大小在类加载完成后便确定了，接下来就是从 Java "),_("strong",[a._v("堆（Heap）")]),a._v(" 中划分一块"),_("strong",[a._v("足够的空间")]),a._v("给新对象。")]),a._v(" "),_("ul",[_("li",[_("strong",[a._v("划分方式")]),a._v("：\n"),_("ul",[_("li",[_("strong",[a._v("指针碰撞（Pointer Bumping）")]),a._v("：如果堆内存是规整的（如使用 Mark-Compact 算法），只需移动指针。")]),a._v(" "),_("li",[_("strong",[a._v("空闲列表（Free List）")]),a._v("：如果堆内存是不连续的，则需要在列表中找到足够大的空闲块。")])])]),a._v(" "),_("li",[_("strong",[a._v("并发处理 (Concurrency Handling)")]),a._v("：由于对象创建非常频繁，多线程同时分配内存可能导致分配指针冲突，JVM 通常采用两种方式解决：\n"),_("ul",[_("li",[_("strong",[a._v("CAS (Compare-and-Swap)")]),a._v("：对分配动作加锁，失败了重试。")]),a._v(" "),_("li",[_("strong",[a._v("TLAB (Thread Local Allocation Buffer)")]),a._v("：为每个线程预先在 Eden 区划分一块专属的私有空间。线程优先在自己的 TLAB 上分配，用完了再申请新的 TLAB。")])])])]),a._v(" "),_("h3",{attrs:{id:"_3-初始化为零值-zero-initialization"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-初始化为零值-zero-initialization"}},[a._v("#")]),a._v(" 3. 初始化为零值 (Zero Initialization)")]),a._v(" "),_("p",[a._v("分配到的内存空间（不包括对象头）会被统一初始化为零值（例如 "),_("code",[a._v("int")]),a._v(" 为 0，"),_("code",[a._v("boolean")]),a._v(" 为 "),_("code",[a._v("false")]),a._v("，引用为 "),_("code",[a._v("null")]),a._v("）。")]),a._v(" "),_("ul",[_("li",[_("strong",[a._v("目的")]),a._v("：确保对象的实例字段在 Java 代码中即使没有赋初值，也可以直接使用对应的零值。")])]),a._v(" "),_("h3",{attrs:{id:"_4-设置对象头-object-header-setup"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-设置对象头-object-header-setup"}},[a._v("#")]),a._v(" 4. 设置对象头 (Object Header Setup)")]),a._v(" "),_("p",[a._v("JVM 会设置新对象的"),_("strong",[a._v("对象头（Header）")]),a._v("，主要包含两部分信息：")]),a._v(" "),_("ul",[_("li",[_("strong",[a._v("运行时元数据（Mark Word）")]),a._v("：包括哈希码、GC 年龄、锁状态标志位（偏向锁、轻量级锁等）。")]),a._v(" "),_("li",[_("strong",[a._v("类型指针")]),a._v("：指向该对象所属类的元数据（让 JVM 知道这个对象是哪个类的实例）。")])]),a._v(" "),_("h3",{attrs:{id:"_5-执行构造函数-init-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-执行构造函数-init-方法"}},[a._v("#")]),a._v(" 5. 执行构造函数 ( "),_("code",[a._v("<init>")]),a._v(" 方法)")]),a._v(" "),_("p",[a._v("执行 Java 代码中的 "),_("code",[a._v("<init>")]),a._v(" 方法（即我们定义的"),_("strong",[a._v("构造函数")]),a._v("）。")]),a._v(" "),_("ul",[_("li",[a._v("执行构造函数是为了给对象的实例字段赋予程序期望的初始值，"),_("strong",[a._v("这个阶段才是真正的初始化")]),a._v("。")])]),a._v(" "),_("h3",{attrs:{id:"_6-返回对象引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-返回对象引用"}},[a._v("#")]),a._v(" 6. 返回对象引用")]),a._v(" "),_("p",[a._v("至此，一个对象创建完成。JVM 将创建好的对象引用（Reference）赋值给程序中的变量，供后续使用。")]),a._v(" "),_("p",[_("img",{attrs:{src:"http://rainyudianxx.baimuxym.cn/HelloCoder/blog/deepseek_mermaid_20251203_33a05c.png",alt:""}})])])}),[],!1,null,null,null);_.default=e.exports}}]);