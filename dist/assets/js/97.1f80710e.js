(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{513:function(v,_,t){"use strict";t.r(_);var n=t(7),o=Object(n.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("在可重复读的情况下，MySQL引入MVCC，但MVCC"),_("strong",[v._v("并没有真正解决了幻读")]),v._v("。")]),v._v(" "),_("p",[v._v("可重复读开启了间隙锁，而间隙锁解决了幻读。")]),v._v(" "),_("p",[v._v("所以在可重复读下用间隙锁或next key锁才可以防止幻读。不使用间隙锁是无法解决幻读的。其实在读提交下检测唯一索引的唯一性也会开启间隙锁。")]),v._v(" "),_("blockquote",[_("p",[v._v("注意，这里说的是针对同一条数据。")])]),v._v(" "),_("p",[v._v("如果针对同一个表但是不是同一条数据，那么可以说，不遵循前提条件，嗯，就是间隙锁之外，锁不住的就无法解决幻读问题。在间隙锁之内的，就能解决幻读。")]),v._v(" "),_("p",[v._v("看面试官是否认为这是同一条数据吧。")]),v._v(" "),_("p",[_("strong",[v._v("如何解决幻读？")])]),v._v(" "),_("p",[v._v("很明显可重复读的隔离级别没有办法彻底的解决幻读的问题，如果我们的项目中需要解决幻读的话也有两个办法：")]),v._v(" "),_("ul",[_("li",[v._v("使用串行化读的隔离级别")]),v._v(" "),_("li",[v._v("MVCC+next-key locks：next-key locks由record locks(索引加锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)")])]),v._v(" "),_("p",[v._v("其实幻读也大可不必一定要消除，毕竟幻读也是可以接受的。")]),v._v(" "),_("p",[v._v("但面试中面试官问你如何消除幻读，你回答说 把隔离级别改成 串行化 那是不行的。")]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("MVCC 和 幻读 的例子、详细过程的可以参考：https://juejin.cn/post/6844903799534911496")])])}),[],!1,null,null,null);_.default=o.exports}}]);