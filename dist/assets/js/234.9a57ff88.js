(window.webpackJsonp=window.webpackJsonp||[]).push([[234],{638:function(v,_,s){"use strict";s.r(_);var t=s(7),a=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"类加载过程以及加载机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载过程以及加载机制"}},[v._v("#")]),v._v(" 类加载过程以及加载机制")]),v._v(" "),_("p",[_("strong",[v._v("类加载器的种类：")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；")]),v._v(" "),_("p",[v._v("其他类加载器：")])]),v._v(" "),_("li",[_("p",[v._v("扩展类加载器（Extension ClassLoader）：负责加载\\lib\\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；")])]),v._v(" "),_("li",[_("p",[v._v("应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。")])])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/DogerRain/image@main/img/image-20200917103311630.png",alt:" "}})]),v._v(" "),_("p",[v._v("类加载器 就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。")]),v._v(" "),_("p",[v._v("加载过程：")]),v._v(" "),_("p",[_("strong",[v._v("加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载")])]),v._v(" "),_("p",[_("strong",[v._v("验证 -> 准备 -> 解析")]),v._v(" 这三步合起来称为 "),_("strong",[v._v("连接")])]),v._v(" "),_("p",[v._v("1."),_("strong",[v._v("加载")])]),v._v(" "),_("p",[v._v("​     加载简单来说分为三步。")]),v._v(" "),_("p",[v._v("第一步：获取二进制字节流也就是上面的class文件。")]),v._v(" "),_("p",[v._v("第二步：将静态的存储结构转换为方法区中的运行时数据结构。")]),v._v(" "),_("p",[v._v("第三步：生成一个对象放入java堆中，做为对方法区的引用。")]),v._v(" "),_("p",[v._v("（类的加载就是将class文件中的二进制数据读取到内存中，然后将该字节流所代表的静态数据结构转化为方法区中运行的数据结构，并且在堆内存中生成一个java.lang.Class对象作为访问方法区数据结构的入口）")]),v._v(" "),_("p",[v._v("2."),_("strong",[v._v("验证")])]),v._v(" "),_("p",[v._v("验证主要是检验如下的几项是否正确")]),v._v(" "),_("p",[v._v("​    class文件的表示（魔数），class文件的版本号，class文件的每个部分是否正确（字段表、方法表等），验证常量池（常量类型、常量类型数据结构是否正确，utf-8是否标准），元数据验证（父类验证，继承验证，final验证），字节码（指令）验证，符号引用验证（是否能根据符号找到对应的字段、表、方法等）")]),v._v(" "),_("p",[v._v("如果一项不对，就会验证失败。")]),v._v(" "),_("p",[v._v("3."),_("strong",[v._v("准备")])]),v._v(" "),_("p",[v._v("准备阶段为类变量分配内存 和设置类变量初始化。这个过程中，只对static类变量进行内存分配，这个时候只是分配内存，没有进行复制，所有的类变量都是初始化值。如果是final的话，会直接对应到常量池中。会在准备阶段直接赋值。")]),v._v(" "),_("p",[v._v("4."),_("strong",[v._v("解析")])]),v._v(" "),_("p",[v._v("解析阶段是读符号引用进行解析。将符号引用解析为直接引用（指向目标的指针或者偏移量）。主要涉及到的解析有类，接口，字段，方法等。")]),v._v(" "),_("p",[v._v("5."),_("strong",[v._v("初始化")])]),v._v(" "),_("p",[v._v("初始化就是执行"),_("code",[v._v("<clinte><linte>")]),v._v("方法的过程， "),_("code",[v._v("<clinte>")]),v._v("对静态变量，静态代码块进行初始化，"),_("code",[v._v("<linte>")]),v._v("对类进行初始化。")]),v._v(" "),_("p",[v._v("6."),_("strong",[v._v("使用")])]),v._v(" "),_("p",[v._v("使用阶段就是使用这个class。")]),v._v(" "),_("p",[v._v("7."),_("strong",[v._v("卸载")])]),v._v(" "),_("p",[v._v("卸载阶段就是不在使用，将class给卸载。")])])}),[],!1,null,null,null);_.default=a.exports}}]);