(window.webpackJsonp=window.webpackJsonp||[]).push([[229],{626:function(a,t,s){"use strict";s.r(t);var n=s(7),e=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("happen-before 和 指令重排序不是一个概念。")]),a._v(" "),t("p",[a._v("要清楚happen-before ，首先要知道Java内存模型。")]),a._v(" "),t("h2",{attrs:{id:"指令重排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令重排序"}},[a._v("#")]),a._v(" 指令重排序")]),a._v(" "),t("p",[a._v("在执行程序时，"),t("strong",[a._v("为了提高性能，编译器和处理器常常会对指令进行重排序")]),a._v("。")]),a._v(" "),t("p",[t("em",[a._v("所以说我们书写代码的顺序，并不是等同于代码在CPU真正执行的顺序。")])]),a._v(" "),t("p",[a._v("这些重排序会导致线程安全的问题，一个很经典的例子就是双重锁定检查（DCL）。")]),a._v(" "),t("p",[a._v("DCL问题可以看看： https://www.jianshu.com/p/ca19c22e02f4 （单例模式）")]),a._v(" "),t("p",[a._v("JMM的编译器重排序规则会禁止一些特定类型的编译器重排序；针对处理器重排序，编译器在生成指令序列的时候会通过"),t("strong",[a._v("插入内存屏障")]),a._v("指令来禁止某些特殊的处理器重排序。")]),a._v(" "),t("p",[t("strong",[a._v("内存屏障")])]),a._v(" "),t("p",[a._v("编译器和处理器都必须遵守重新排序规则。不需要特别的努力来确保单处理器保持适当的顺序，因为它们都保证“按顺序”一致性。但是在多处理器上，要保证一致性，通常需要发出屏障指令。即使编译器优化了字段访问（例如，因为未使用加载的值），也必须仍然生成屏障，就像访问仍然存在一样。")]),a._v(" "),t("blockquote",[t("p",[a._v("内存屏障的概念以及：http://gee.cs.oswego.edu/dl/jmm/cookbook.html")])]),a._v(" "),t("p",[a._v("指令重排序可以分为三种：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://blog-1253198264.cos.ap-guangzhou.myqcloud.com/20181009231337835",alt:""}})]),a._v(" "),t("p",[a._v("（1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；\n（2）指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；\n（3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。")]),a._v(" "),t("p",[a._v("比如说：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/DogerRain/image@main/img/20181009231434528",alt:""}})]),a._v(" "),t("p",[a._v("由于A,B之间没有任何关系，对最终结果也不会存在关系，它们之间执行顺序可以重排序。因此可以执行顺序可以是A->B->C或者B->A->C执行最终结果都是3.14，即A和B之间没有数据依赖性。")]),a._v(" "),t("p",[a._v("以上部分参考自：https://blog.csdn.net/ma_chen_qq/article/details/82990603")]),a._v(" "),t("h2",{attrs:{id:"happen-before"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#happen-before"}},[a._v("#")]),a._v(" happen-before")]),a._v(" "),t("p",[a._v("happen-before 是 Java 内存模型中保证多线程操作可见性的机制，也是对早期语言规范中含糊的可见性概念的一个精确定义。")]),a._v(" "),t("p",[a._v("内存模型通过happen-before 关系向程序员提供跨线程的内存可见保证性（"),t("strong",[a._v("如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见")]),a._v("）。")]),a._v(" "),t("p",[t("strong",[a._v("具体的定义为：")]),a._v("\n1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。")]),a._v(" "),t("p",[a._v("2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。")]),a._v(" "),t("p",[a._v("happen-before规则一共就八条：")]),a._v(" "),t("h3",{attrs:{id:"_1、单线程happen-before原则-在同一个线程中-书写在前面的操作happen-before后面的操作。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、单线程happen-before原则-在同一个线程中-书写在前面的操作happen-before后面的操作。"}},[a._v("#")]),a._v(" 1、单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。")]),a._v(" "),t("p",[a._v("比如说：")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("      "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//1")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" b "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//2")]),a._v("\n")])])]),t("p",[a._v("这里 //1对变量a的赋值操作对//2一定可见。")]),a._v(" "),t("p",[a._v("因为//2 中有用到//1中的变量a，再加上java内存模型提供了“单线程happen-before原则”，所以java虚拟机不许可操作系统对//1 //2 操作进行指令重排序。")]),a._v(" "),t("p",[a._v("如果是：")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" b "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("指令重排序则可能发生。")]),a._v(" "),t("h3",{attrs:{id:"_2、锁的happen-before原则-同一个锁的unlock操作happen-before此锁的lock操作。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、锁的happen-before原则-同一个锁的unlock操作happen-before此锁的lock操作。"}},[a._v("#")]),a._v(" 2、锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。")]),a._v(" "),t("p",[a._v("常见的就是synchronized、reentrantLock加锁。")]),a._v(" "),t("p",[a._v("解锁操作的结果对后面的加锁操作一定是可见的，无论两个是否在一个线程；简单的说就是线程A加了锁，在我没有解锁之前，线程B是无法进入的，而当线程A解锁了，线程B是可以感知的。")]),a._v(" "),t("p",[a._v("例子就不举了，前面的synchronized文章有说到。")]),a._v(" "),t("h3",{attrs:{id:"_3、volatile的happen-before原则-对一个volatile变量的写操作happen-before对此变量的任意操作。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、volatile的happen-before原则-对一个volatile变量的写操作happen-before对此变量的任意操作。"}},[a._v("#")]),a._v(" 3、volatile的happen-before原则： 对一个volatile变量的写操作happen-before对此变量的任意操作。")]),a._v(" "),t("p",[a._v("对 volatile 变量的写操作的结果对于发生于其后的任何操作的结果都是可见的。x86 架构下volatile 通过"),t("strong",[a._v("内存屏障")]),a._v("和"),t("strong",[a._v("缓存一致性协议")]),a._v("实现了变量在多核心之间的一致性。")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//线程A执行")]),a._v("\na "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//1")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//线程B执行")]),a._v("\nb "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//2")]),a._v("\n")])])]),t("p",[a._v("如果线程A 执行//1，线程B执行了//2，并且“线程A”执行后,“线程B”再执行,那么符合“volatile的happen-before原则”所以“线程2”中的a值一定是1，而不会是初始值0。")]),a._v(" "),t("h3",{attrs:{id:"_4、happen-before的传递性原则-如果a操作-happen-before-b操作-b操作happen-before-c操作-那么a操作happen-before-c操作。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、happen-before的传递性原则-如果a操作-happen-before-b操作-b操作happen-before-c操作-那么a操作happen-before-c操作。"}},[a._v("#")]),a._v(" 4、happen-before的传递性原则：  如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。")]),a._v(" "),t("p",[a._v("可以根据这两个规则推导出两个没有直接联系的操作其实是存在happen-before 关系的。")]),a._v(" "),t("h4",{attrs:{id:"_5、-线程启动的happen-before原则-同一个线程的start方法happen-before此线程的其它方法。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、-线程启动的happen-before原则-同一个线程的start方法happen-before此线程的其它方法。"}},[a._v("#")]),a._v(" 5、 线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。")]),a._v(" "),t("p",[a._v("翻译成人话就是：我在main线程 赋值了一个字段，下一步我又通过"),t("code",[a._v("start()")]),a._v("启动一个线程，那么这个main线程赋值操作对子线程是可见的。")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//main线程")]),a._v("\na "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("start")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//子线程")]),a._v("\nb "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// b等于1")]),a._v("\n")])])]),t("h3",{attrs:{id:"_6、线程中断的happen-before原则-对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、线程中断的happen-before原则-对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。"}},[a._v("#")]),a._v(" 6、线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。")]),a._v(" "),t("h3",{attrs:{id:"_7、-线程终结的happen-before原则-线程中的所有操作都happen-before线程的终止检测-又叫做join规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7、-线程终结的happen-before原则-线程中的所有操作都happen-before线程的终止检测-又叫做join规则"}},[a._v("#")]),a._v(" 7、 线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测，又叫做join规则")]),a._v(" "),t("p",[a._v("这两点可以理解为线程之间的通信，主线程对子线程发出通知，子线程是可以感知的。同时主线程可以感知子线程的状态。")]),a._v(" "),t("h3",{attrs:{id:"_8、-对象finalize规则-一个对象的初始化完成-构造函数执行结束-先行于发生它的finalize-方法的开始。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8、-对象finalize规则-一个对象的初始化完成-构造函数执行结束-先行于发生它的finalize-方法的开始。"}},[a._v("#")]),a._v(" 8、 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。")]),a._v(" "),t("p",[a._v("即先有类的初始化才有销毁，感觉这个和类加载器有关系。")]),a._v(" "),t("hr"),a._v(" "),t("p",[a._v("happen-before，它不能简单地说前后关系，是因为它不仅仅是对执行时间的保证，也包括对内存读、写操作顺序的保证。")]),a._v(" "),t("p",[a._v("它和时间没有任何关系，仅仅是时钟顺序上的先后，并不能保证线程交互的可见性。")]),a._v(" "),t("p",[a._v("对于学习JMM，个人觉得不要陷得太深，毕竟这东西和CPU打交道，纠结于这些复杂的东西，未必有价值。")]),a._v(" "),t("h2",{attrs:{id:"拓展-dcl的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拓展-dcl的问题"}},[a._v("#")]),a._v(" 拓展：DCL的问题")]),a._v(" "),t("p",[a._v("double-check-locking")]),a._v(" "),t("p",[a._v("先来看看常用第一种的单例模式：")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),a._v(" instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 1")]),a._v("\n            instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" instance"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("假如两个并发线程同时 getInstance()，线程A先判断是否为null，即"),t("code",[a._v("// 1")]),a._v(" 处；刚判断完jvm将cpu资源给了线程B，由于线程B没有执行到"),t("code",[a._v("// 2")]),a._v(" 处，所以 instance 还是空的，线程B就new了，然后又切换为线程A，又new一次，这样就会导致单例类被实例化两次。")]),a._v(" "),t("blockquote",[t("p",[a._v("既然需要有序性，可以加synchronized")])]),a._v(" "),t("p",[a._v("第二次改进：")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),a._v(" instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//加锁，但是不要在外面加，每次调用这个方法就很耗时了，重量级")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//    public synchronized static SingleInstance getInstanceSync() {")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getInstanceSync")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//这种也没啥意义，一样是重量级的，每次进入都需要检查")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("synchronized")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 1")]),a._v("\n                instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" instance"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("上面是加了"),t("code",[a._v("synchronized")]),a._v("之后的版本，会避免多个线程产生多个实例，但是这种方法会影响性能。")]),a._v(" "),t("p",[a._v("可以改成这样：")]),a._v(" "),t("p",[a._v("第三次改进：")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\t"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),a._v(" instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getInstanceSync")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("synchronized")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 1")]),a._v("\n                    instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2")]),a._v("\n                "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" instance"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("但是还是会有问题。")]),a._v(" "),t("p",[t("code",[a._v("instance = new SingleInstance()")]),a._v("这里看起来是一句话，但实际上它并不是一个原子操作（原子操作的意思就是这条语句要么就被执行完，要么就没有被执行过，不能出现执行了一半这种情形）。事实上高级语言里面非原子操作有很多，我们只要看看这句话被编译后在JVM执行的对应汇编代码就发现，这句话被编译成8条汇编指令，大致做了3件事情：")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("给SingleInstance的实例分配内存。")])]),a._v(" "),t("li",[t("p",[a._v("初始化SingleInstance的构造器。")])]),a._v(" "),t("li",[t("p",[a._v("将instance对象"),t("strong",[a._v("指向")]),a._v("分配的内存空间（注意到这步instance就非null了）。")])])]),a._v(" "),t("p",[a._v("但是，由于Java编译器允许处理器乱序执行（out-of-order），以及JDK1.5之前JMM（Java Memory Medel）中Cache、寄存器到主内存回写顺序的规定，上面的第2点和第3点的顺序是无法保证的，也就是说，执行顺序可能是"),t("code",[a._v("1-2-3")]),a._v("也可能是"),t("code",[a._v("1-3-2")]),a._v("，如果是后者，并且在3执行完毕、2未执行之前，被切换到线程二上，这时候instance因为已经在线程一内执行过了第三点，instance已经是非空了，所以线程二直接拿走instance，然后使用，然后就会报错了。")]),a._v(" "),t("blockquote",[t("p",[a._v("简单来说可能存在某个线程拿到了一个没有执行构造方法的对象")])]),a._v(" "),t("p",[a._v("第四次改进：")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\t"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),a._v(" instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getInstanceSync")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("synchronized")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 1")]),a._v("\n                    instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingleInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2")]),a._v("\n                "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" instance"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("在Java中设置变量值的操作，除了long和double类型的变量外都是原子操作，也就是说，对于变量值的简单读写操作没有必要进行同步。")]),a._v(" "),t("blockquote",[t("p",[a._v("于long和double变量，把他们作为2个原子性的32位值来对待，而不是一个原子性的64位值，\n这样将一个long型的值保存到内存的时候，可能是2次32位的写操作，\n2个竞争线程想写不同的值到内存的时候，可能导致内存中的值是不正确的结果。")]),a._v(" "),t("p",[a._v("1、写入高位32位值(线程2)\n2、写入高位32位值(线程1)\n3、写入低位32位值(线程1)\n4、写入低位32位值(线程2)")]),a._v(" "),t("p",[a._v("这样内存中的值变成线程1的高32位值和线程2的低32位值的组合，是个错误的值。volatile本身不保证获取和设置操作的原子性，仅仅保持修改的可见性。但是java内存模型保证声明为volatile的long和double变量的get和set操作是原子的。")]),a._v(" "),t("p",[a._v("作者：达微\n链接：https://www.jianshu.com/p/f40d96d91c1c")])]),a._v(" "),t("p",[a._v("上面这个例子使用volatile屏蔽掉了VM中必要的代码优化（防止指令重排序），所以在效率上比较低，会带来一些性能问题，因此一定在必要时才使用此关键字。")])])}),[],!1,null,null,null);t.default=e.exports}}]);