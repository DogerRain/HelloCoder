(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{479:function(_,v,t){"use strict";t.r(v);var e=t(7),r=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("三色标记法是一种垃圾回收法，它可以让JVM不发生或仅短时间发生STW(Stop The World)，从而达到清除JVM内存垃圾的目的。")]),_._v(" "),v("p",[_._v("JVM中的"),v("strong",[_._v("CMS、G1垃圾回收器")]),_._v("所使用垃圾回收算法即为三色标记法。")]),_._v(" "),v("p",[_._v("之前提到的"),v("strong",[_._v("CMS、G1垃圾回收器")]),_._v("所使用垃圾回收算法，分为四个步骤，这四个步骤各不相同，其中标志垃圾的状态和JVM判断垃圾是否需要回收的算法——可达性分析法也有关系。")]),_._v(" "),v("h2",{attrs:{id:"_1、可达性分析法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、可达性分析法"}},[_._v("#")]),_._v(" 1、可达性分析法")]),_._v(" "),v("p",[_._v("这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain)。")]),_._v(" "),v("p",[_._v("当一个对象到GC Roots没有任何引用链相连时（不可达）则证明此对象是不可用的。")]),_._v(" "),v("h2",{attrs:{id:"_2、三色标记算法思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、三色标记算法思想"}},[_._v("#")]),_._v(" 2、三色标记算法思想")]),_._v(" "),v("p",[_._v("三色标记法将对象的颜色分为了黑、灰、白，三种颜色。")]),_._v(" "),v("p",[v("strong",[_._v("白色")]),_._v("：该对象没有被标记过。（对象垃圾）")]),_._v(" "),v("p",[v("strong",[_._v("灰色")]),_._v("：该对象已经被标记过了，但该对象下的属性没有全被标记完。（GC需要从此对象中去寻找垃圾）")]),_._v(" "),v("p",[v("strong",[_._v("黑色")]),_._v("：该对象已经被标记过了，且该对象下的属性也全部都被标记过了。（程序所需要的对象）")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/DogerRain/image@main/Home/image-20211018100046048.png",alt:""}})]),_._v(" "),v("h3",{attrs:{id:"算法流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#算法流程"}},[_._v("#")]),_._v(" 算法流程")]),_._v(" "),v("p",[_._v("1、从我们"),v("code",[_._v("main")]),_._v("方法的根对象（JVM中称为"),v("code",[_._v("GC Root")]),_._v("）开始沿着他们的对象向下查找，用黑灰白的规则，标记出所有跟"),v("code",[_._v("GC Root")]),_._v("相连接的对象（不递归），扫描一遍结束后，一般需要进行一次短暂的STW(Stop The World)")]),_._v(" "),v("p",[_._v("2、只需找出灰色对象并顺着继续往下标记（且因为大部分的标记工作已经在第一次并发的时候发生了，所以灰色对象数量会很少，标记时间也会短很多）, 此时程序继续执行，"),v("code",[_._v("GC")]),_._v("线程扫描所有的内存，找出扫描之后依旧被标记为白色的对象（垃圾），清除。")]),_._v(" "),v("p",[_._v("具体流程:")]),_._v(" "),v("ol",[v("li",[_._v("首先创建三个集合：白、灰、黑。")]),_._v(" "),v("li",[_._v("将所有对象放入白色集合中。")]),_._v(" "),v("li",[_._v("然后从根节点开始遍历所有对象（注意这里并不"),v("strong",[_._v("递归遍历")]),_._v("），把遍历到的对象从白色集合放入灰色集合。")]),_._v(" "),v("li",[_._v("之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合")]),_._v(" "),v("li",[_._v("重复 4 直到灰色中无任何对象")]),_._v(" "),v("li",[_._v("通过write-barrier检测对象有变化，重复以上操作")]),_._v(" "),v("li",[_._v("收集所有白色对象（垃圾）")])]),_._v(" "),v("p",[_._v("看到这里，这不就是"),v("strong",[_._v("CMS、G1垃圾回收器")]),_._v("所使用垃圾回收算法吗？")]),_._v(" "),v("p",[_._v("所以也就恍然大悟了。")]),_._v(" "),v("p",[_._v("CMS、G1的垃圾回收算法和"),v("code",[_._v("可达性分析法")]),_._v("也有很大关系，所以才会出现这种分批次标志的回收过程。")]),_._v(" "),v("h2",{attrs:{id:"_3、g1会不会full-gc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、g1会不会full-gc"}},[_._v("#")]),_._v(" 3、G1会不会full  gc？")]),_._v(" "),v("p",[_._v("肯定会。")]),_._v(" "),v("p",[_._v("虽然说 G1 回收器相比其他回收器要好，但G1也有缺点，而且在 "),v("strong",[_._v("初始标记 、 最终标记 还是会发生full gc")])]),_._v(" "),v("p",[_._v("且"),v("code",[_._v("JDK10")]),_._v("之前的"),v("code",[_._v("Full GC")]),_._v("，为单线程的，所以使用G1需要避免"),v("code",[_._v("Full GC")]),_._v("的产生。")]),_._v(" "),v("p",[_._v("解决方案：")]),_._v(" "),v("ul",[v("li",[_._v("加大内存；")]),_._v(" "),v("li",[_._v("提高CPU性能，加快GC回收速度，而对象增加速度赶不上回收速度，则Full GC可以避免；")]),_._v(" "),v("li",[_._v("降低进行Mixed GC触发的阈值，让Mixed GC提早发生（默认45%）J")])]),_._v(" "),v("hr"),_._v(" "),v("p",[_._v("参考：")]),_._v(" "),v("ul",[v("li",[_._v("https://mp.weixin.qq.com/s/flYwD0e9fXBU_wGT7Wg8eA")])])])}),[],!1,null,null,null);v.default=r.exports}}]);